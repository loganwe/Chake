<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chake</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            margin: 0;
            height: 100vh;
            align-items: center;
            background-color: black;
        }

        canvas {
            background-color: white;
            border: 2px solid darkgreen;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.querySelector("canvas");
        const c = canvas.getContext("2d");
        canvas.width = 1024;
        canvas.height = 576;

        const snakeSize = 20; // Size of each snake segment
        const maxLength = 50; // Maximum length of the snake
        let s1Direction = { x: 0, y: 0 }; // Initial direction for snake 1
        let s1NewDirection = { x: 0, y: 0 }; // Direction change for snake 1
        let s2Direction = { x: 0, y: 0 }; // Initial direction for snake 2
        let s2NewDirection = { x: 0, y: 0 }; // Direction change for snake 2
        let gameOver = false; // Game over flag
        let winner = null; // Variable to store the winner
        const lastRowY = canvas.height - snakeSize; // Y coordinate of the last row
        const firstRowY = 0; // Y coordinate of the first row
        let currentTurn = 1; // Variable to track whose turn it is (1 for Snake 1, 2 for Snake 2)

        class Snake {
            constructor({ position, color }) {
                this.position = position; // Starting position of snake's head
                this.size = snakeSize; // Snake segment size
                this.segments = []; // Snake segments
                this.color = color;

                // Initialize snake's body with 1 segment
                this.segments.push({ x: this.position.x, y: this.position.y });
            }

            draw() {
                c.fillStyle = this.color;
                this.segments.forEach(segment => {
                    c.fillRect(segment.x, segment.y, this.size, this.size);
                });
            }

            moveSnake(direction, opponentSnake) {
                if (gameOver) return false; // Stop the game if it's over

                // Calculate the next head position based on the current direction
                const nextHeadX = this.segments[0].x + direction.x * this.size;
                const nextHeadY = this.segments[0].y + direction.y * this.size;

                // Check if the next move is within canvas bounds
                if (
                    nextHeadX >= 0 && nextHeadX + this.size <= canvas.width && // X bounds
                    nextHeadY >= 0 && nextHeadY + this.size <= canvas.height  // Y bounds
                ) {
                    // Check for collision with the opponent's segments
                    if (opponentSnake.segments.some(segment =>
                        nextHeadX === segment.x && nextHeadY === segment.y)) {
                        console.log("Collision with opponent! Move not allowed.");
                        gameOver = true;
                        winner = opponentSnake.color;
                        return false; // Invalid move, don't switch turns
                    }

                    // Check for self-collision
                    if (this.segments.some((segment, index) => index !== 0 && segment.x === nextHeadX && segment.y === nextHeadY)) {
                        console.log("Self-collision! Move not allowed.");
                        gameOver = true;
                        winner = opponentSnake.color;
                        return false; // Invalid move, don't switch turns
                    }

                    // Move snake's body (each segment follows the one in front)
                    const oldTail = this.segments[this.segments.length - 1]; // Save old tail position
                    for (let i = this.segments.length - 1; i > 0; i--) {
                        this.segments[i] = { ...this.segments[i - 1] };
                    }

                    // Move the head based on direction
                    this.segments[0].x = nextHeadX;
                    this.segments[0].y = nextHeadY;

                    // Grow the snake if it's not at max length
                    if (this.segments.length < maxLength) {
                        this.segments.push({ ...oldTail }); // Add a new segment at the tail position
                    }

                    return true; // Valid move, switch turn
                } else {
                    console.log("Snake hit the boundary! Move not allowed.");
                    return false; // Invalid move, don't switch turns
                }
            }
        }

        // Center X based on grid size
        const centerX = Math.floor(canvas.width / 2 / snakeSize) * snakeSize;

        // Start snake1 (green) at the bottom center and snake2 (red) at the top center
        const snake1 = new Snake({
            position: { x: centerX, y: lastRowY }, color: "Green"
        });
        const snake2 = new Snake({
            position: { x: centerX, y: firstRowY }, color: "Red"
        });

        // Handle keyboard input for both snakes
        window.addEventListener("keydown", (event) => {
            if (!gameOver) {
                // Snake 1 controls (Arrow keys)
                if (currentTurn === 1) {
                    switch (event.key) {
                        case "ArrowUp":
                            if (s1Direction.y === 0) s1NewDirection = { x: 0, y: -1 };
                            break;
                        case "ArrowDown":
                            if (s1Direction.y === 0) s1NewDirection = { x: 0, y: 1 };
                            break;
                        case "ArrowLeft":
                            if (s1Direction.x === 0) s1NewDirection = { x: -1, y: 0 };
                            break;
                        case "ArrowRight":
                            if (s1Direction.x === 0) s1NewDirection = { x: 1, y: 0 };
                            break;
                    }

                    if (event.key.startsWith("Arrow")) {
                        const validMove = snake1.moveSnake(s1NewDirection, snake2);
                        if (validMove) {
                            s1Direction = { ...s1NewDirection };
                            currentTurn = 2;
                        }
                    }
                }

                // Snake 2 controls (WASD keys)
                if (currentTurn === 2) {
                    switch (event.key) {
                        case "w":
                            if (s2Direction.y === 0) s2NewDirection = { x: 0, y: -1 };
                            break;
                        case "s":
                            if (s2Direction.y === 0) s2NewDirection = { x: 0, y: 1 };
                            break;
                        case "a":
                            if (s2Direction.x === 0) s2NewDirection = { x: -1, y: 0 };
                            break;
                        case "d":
                            if (s2Direction.x === 0) s2NewDirection = { x: 1, y: 0 };
                            break;
                    }

                    if (["w", "a", "s", "d"].includes(event.key)) {
                        const validMove = snake2.moveSnake(s2NewDirection, snake1);
                        if (validMove) {
                            s2Direction = { ...s2NewDirection };
                            currentTurn = 1;
                        }
                    }
                }

                draw();
            }
        });

        function draw() {
            // Clear the canvas
            c.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the checkered background
            const squareSize = snakeSize;
            const offsetX = snake1.segments[0].x % squareSize;
            const offsetY = snake1.segments[0].y % squareSize;

            for (let y = offsetY; y < canvas.height; y += squareSize) {
                for (let x = offsetX; x < canvas.width; x += squareSize) {
                    if ((Math.floor((x - offsetX) / squareSize) + Math.floor((y - offsetY) / squareSize)) % 2 === 0) {
                        c.fillStyle = "lightgray";
                    } else {
                        c.fillStyle = "darkgray";
                    }
                    c.fillRect(x, y, squareSize, squareSize);
                }
            }

            // Draw both snakes
            snake1.draw();
            snake2.draw();

            // Display current turn
            c.font = "40px Arial";
            c.fillStyle = "black";
            c.fillText("Turn: " + currentTurn, 50, 50);

            // Display game over message
            if (gameOver) {
                c.font = "50px Arial";
                c.fillStyle = "red";
                c.fillText("Game Over", canvas.width / 2 - 150, canvas.height / 2);
                c.fillText(`${winner} Wins!`, canvas.width / 2 - 150, canvas.height / 2 + 60);
            }
        }

        draw();
    </script>
</body>

</html>
